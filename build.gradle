import org.eclipse.jgit.api.Git
import org.eclipse.jgit.revwalk.RevCommit
import org.eclipse.jgit.revwalk.RevWalk
import org.eclipse.jgit.lib.Constants
import org.eclipse.jgit.awtui.AwtCredentialsProvider

apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'idea'

task wrapper(type: Wrapper) { gradleVersion = '1.6' }

buildscript {
    repositories {
        mavenCentral()
        maven { url 'https://oss.sonatype.org/content/groups/public/' }
    }

    dependencies {
        classpath 'org.eclipse.jgit:org.eclipse.jgit:2.0.0.201206130900-r',
                'org.eclipse.jgit:org.eclipse.jgit.ui:2.0.0.201206130900-r'
    }
}

final USER_HOME = System.properties['user.home']
final BUILDS_DIR = 'builds'
final RELEASES_DIR = 'releases'
final REPOSITORY = "${USER_HOME}/Dropbox/personal/repository"
final JAVA_VERSION = '1.6'
final RC_ROBOTS_DIR = "${USER_HOME}/opt/rc/robots"
final RCC_ROBOTS_DIR = "${USER_HOME}/opt/rcc/robots"

project.ext.set('git', Git.open(file(projectDir)))
project.ext.set('repository', git.repository)
project.ext.set("RCC_ROBOTS_DIR", "${USER_HOME}/opt/rcc/robots")
project.ext.set("VERSION_PROPERTIES_FILE", "version.properties")

group = 'lxx'
targetCompatibility = JAVA_VERSION
sourceCompatibility = JAVA_VERSION

buildDir = relativePath("${USER_HOME}/builds/${name}")

def versionProps = versionProps()
def major = versionProps['major']
String minor = versionProps['minor']
def build = versionProps['build']
def currentVersion = [major: major,
        minor: minor.split('\\.'),
        branch: getBranchAcro(),
        build: build
]
def nextVersion = [:]

gradle.taskGraph.whenReady { taskGraph ->
    if (taskGraph.hasTask(releaseViolet)) {
        nextVersion = getNextVersion(currentVersion, 'release')
        version = "${nextVersion.major}.${nextVersion.minor.join('.')}" // todo: fix this hack

        assertPreconditions("Release ", RELEASES_DIR)

        if (!repository.branch.equals("master")) {
            throw new GradleException("Release must be build from master branch!")
        }
    } else if (taskGraph.hasTask(quickFixRelease)) {
        nextVersion = getNextVersion(currentVersion, 'quickFix')
        version = "${nextVersion.major}.${nextVersion.minor.join('.')}" // todo: fix this hack

        if (currentVersion.build != '0') {
            throw new GradleException("Quick fix may be applied only to release")
        }
        assertPreconditions("Release ", RELEASES_DIR)

        if (!repository.branch.equals("master")) {
            throw new GradleException("Release must be build from master branch!")
        }
    } else {
        nextVersion = getNextVersion(currentVersion, 'build')
        version = "${nextVersion.major}.${nextVersion.minor.join('.')}.${nextVersion.branch}.${nextVersion.build}"

        if (gradle.startParameter.taskNames.contains('installViolet')) {
            assertPreconditions("Build ", BUILDS_DIR)
        }
    }

    jar.archiveName = "${group}.${name}_${version}.jar"
}


repositories {
    mavenCentral()

    ivy {
        url REPOSITORY
        layout 'pattern', {
            final artifactDir = '[organization]/[module]'
            artifact "${artifactDir}/[artifact]-[revision].[ext]"
            ivy "${artifactDir}/ivy.xml"
        }

    }

}

dependencies {
    compile 'robocode:robocode:1.7.4.2',
            'org.codehaus.groovy:groovy:2.0.6'
    testCompile 'junit:junit:4.11'
    testCompile 'org.spockframework:spock-core:0.7-groovy-2.0'
}

task generateProperties {
    inputs.file VERSION_PROPERTIES_FILE
    outputs.file { "${sourceSets.main.resources.srcDirs.iterator().next()}/lxx/${project.name}.properties" }
}

generateProperties << {

    def violetProperties = file("${sourceSets.main.resources.srcDirs.iterator().next()}/lxx/${project.name}.properties")
    if (!violetProperties.exists()) {
        violetProperties.getParentFile().mkdirs()
    }
    def vpWriter = violetProperties.newWriter()
    vpWriter << "robot.description=\n"
    vpWriter << "robocode.version=1.7\n"
    vpWriter << "robot.java.source.included=true\n"
    vpWriter << "robot.version=${project.version}\n"
    vpWriter << "robot.author.name=Aleksey Zhidkov\n"
    vpWriter << "robot.classname=lxx.${project.name}\n"
    vpWriter << "robot.name=${project.name}\n"
    vpWriter.flush()
    vpWriter.close()
}

processResources.doFirst {
    project.copy {
        from(sourceSets.main.java)
        into(sourceSets.main.output.classesDir)
    }
}

processResources.dependsOn generateProperties

task copyBuild(type: Copy, dependsOn: assemble) {
    from { jar.archivePath }
    into RC_ROBOTS_DIR
}

tasks.build.dependsOn copyBuild

task installViolet(dependsOn: ':build') << {

    copy(jar.archivePath, [RC_ROBOTS_DIR, RCC_ROBOTS_DIR, BUILDS_DIR])
    updateVersionProperties(nextVersion)
    commitBuild("Build ${version}")
}



task releaseViolet(dependsOn: ':build') << {

    copy(jar.archivePath, [RC_ROBOTS_DIR, RCC_ROBOTS_DIR, RELEASES_DIR])
    updateVersionProperties(nextVersion)
    commitBuild("Release ${version}")
    tagBuild()
    pushMaster()

}

task quickFixRelease(dependsOn: ':build') << {

    copy(jar.archivePath, [RC_ROBOTS_DIR, RCC_ROBOTS_DIR, RELEASES_DIR])
    updateVersionProperties(nextVersion)
    commitBuild("Quick fix release ${version}")
    tagBuild()
    pushMaster()

}

def assertPreconditions(def commitMessage, def buildDst) {
    final rccFile = "${project.RCC_ROBOTS_DIR}/lxx.${project.name}_${version}.jar"
    final buildDstFile = "${buildDst}/lxx.${project.name}_${version}.jar"
    if (new File(buildDstFile).exists()) {
        throw new GradleException("file ${buildDstFile} already exist")
    }
    if (new File(rccFile).exists()) {
        throw new GradleException("file ${rccFile} already exist")
    }

    if (!git.status().call().isClean()) {
        throw new GradleException("Repository is not clean!")
    }

    checkHeadCommit(commitMessage)
}

def checkHeadCommit(def messageStart) {
    def RevWalk rw = new RevWalk(project.repository);
    def headId = project.repository.resolve(Constants.HEAD)
    def RevCommit commitHead = rw.parseCommit(headId);

    if (commitHead.getFullMessage().startsWith(messageStart)) {
        throw new GradleException('No commits detected');
    }
}

def copy(def file, def dests) {

    dests.each { dest ->
        project.copy {
            from file
            into dest
        }
    }

}

def commitBuild(def msg) {
    def addCmd = project.git.add()
    addCmd.addFilepattern('.')
    addCmd.call()

    def commitCmd = project.git.commit()
    commitCmd.setMessage(msg)
    commitCmd.call()
}

def tagBuild() {
    def tagCmd = project.git.tag()
    tagCmd.setName(version)
    tagCmd.call()
}

def pushMaster() {
    def pushCmd = git.push()
    pushCmd.setCredentialsProvider(new AwtCredentialsProvider())
    pushCmd.add('master')
    pushCmd.setPushTags()
    pushCmd.setRemote('origin')
    pushCmd.call()
}

def updateVersionProperties(def version) {
    def versionPropertiesFile = file(VERSION_PROPERTIES_FILE)
    versionPropertiesFile.write "major=${version.major}\n" +
            "minor=${version.minor.join('.')}\n" +
            "build=${version.build}"
}

def getBranchAcro() {
    def currentBranch = project.repository.branch
    def branchAcro = ''
    currentBranch.split('-').each { branchAcro += it.charAt(0).toLowerCase() }
    branchAcro
}

def versionProps() {
    def versionProps = new Properties()
    file(VERSION_PROPERTIES_FILE).withReader { reader ->
        versionProps.load(reader)
    }
    versionProps
}

def getNextVersion(def currentVersion, def type) {
    switch (type) {
        case 'build':
            return [major: currentVersion.major,
                    minor: currentVersion.minor,
                    branch: currentVersion.branch,
                    build: currentVersion.build.toInteger() + 1
            ]

        case 'quickFix':
            if (currentVersion.minor.size() == 1) {
                return [major: currentVersion.major,
                        minor: (currentVersion.minor as List) + '1',
                        branch: currentVersion.branch,
                        build: 0
                ]
            } else {
                def minor = new ArrayList(currentVersion.minor as List)
                minor[minor.size() - 1] = minor[minor.size() - 1].toInteger() + 1
                return [major: currentVersion.major,
                        minor: minor,
                        branch: currentVersion.branch,
                        build: 0
                ]
            }
            break;
        case 'release':
            return [major: currentVersion.major,
                    minor: [currentVersion.minor[0].toInteger() + 1],
                    branch: currentVersion.branch,
                    build: 0
            ]
            break;
    }
}